<% if (order.products[i].orderStatus !== "Cancelled") { %>
    <div class="row d-flex align-items-center" id="status-row-<%= order.products[i]._id %>">
        <div class="col-md-2">
            <p class="text-muted mb-0 small">Track Order</p>
        </div>
        <div class="col-md-10">
            <div class="progress" style="height: 6px; border-radius: 16px">
                <% switch (order.products[i].orderStatus) { %>
                    <% case 'Placed': %>
                        <div class="progress-bar" role="progressbar" style="width: 25%; border-radius: 16px; background-color: #a8729a" aria-valuenow="25" aria-valuemin="0" aria-valuemax="100"></div>
                        <% break %>
                    <% case 'Shipped': %>
                        <div class="progress-bar" role="progressbar" style="width: 50%; border-radius: 16px; background-color: #a8729a" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                        <% break %>
                    <% case 'Out for delivery': %>
                        <div class="progress-bar" role="progressbar" style="width: 75%; border-radius: 16px; background-color: #a8729a" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100"></div>
                        <% break %>
                    <% case 'Delivered': %>
                        <div class="progress-bar" role="progressbar" style="width: 100%; border-radius: 16px; background-color: #a8729a" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"></div>
                        <% break %>
                    <% default: %>
                        <div class="progress-bar" role="progressbar" style="width: 0%; border-radius: 16px; background-color: #a8729a" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                <% } %>
            </div>
            <div class="d-flex justify-content-around mb-1">
                <% if (order.products[i].orderStatus === 'Placed') { %>
                    <p class="text-muted mt-1 mb-0 small ms-xl-5">Order Placed</p>
                <% } else if (order.products[i].orderStatus === 'Shipped') { %>
                    <p class="text-muted mt-1 mb-0 small ms-xl-5">Shipped</p>
                <% } else if (order.products[i].orderStatus === 'Out for delivery') { %>
                    <p class="text-muted mt-1 mb-0 small ms-xl-5">Out for Delivery</p>
                <% } else if (order.products[i].orderStatus === 'Delivered') { %>
                    <p class="text-muted mt-1 mb-0 small ms-xl-5">Delivered</p>
                <% } %>
            </div>
        </div>
    </div>
<% } %>






const User = require('../models/userModel');
const Product = require('../models/productModel');
const Cart = require('../models/cartModel');
const Category = require('../models/categoryModel');
const Admin = require('../models/adminModel');
const fs = require("fs")
const sharp = require('sharp');
const path = require('path');

module.exports = {


    loadUserProducts: async (req, res) => {
        try {
            const categories = await Category.find({ isListed: true });
            const products = await Product.find({ isListed: true }).populate('productCategory');
            res.render('productView', { product: products, category: categories });
        } catch (error) {
            console.log(error.message);
        }
    },

    loadUserProductDetails: async (req, res) => {

        try {
            const id = req.query.id;
            const pro = await Product.findById(id).populate('productCategory productImage');

            res.render('productDetails', { product: pro })
        } catch (error) {
            console.log(error.message);
        }
    },


}



const topCategories = await Order.aggregate([
    {
        $unwind: '$products' // Unwind the products array
    },
    {
        $group: {
            _id: '$products.category', // Group by category
            totalQuantity: { $sum: '$products.quantity' } // Calculate total quantity
        }
    },
    {
        $lookup: {
            from: 'categories', // Assuming your category model is named 'Category'
            localField: '_id',
            foreignField: '_id',
            as: 'categoryDetails'
        }
    },
    {
        $project: {
            categoryName: '$categoryDetails.categoryName', // Include category name in the result
            totalQuantity: 1,
            _id: 0
        }
    },
    {
        $sort: { totalQuantity: -1 } // Sort by total quantity in descending order
    },
    {
        $limit: 3 // Get top 5 categories
    }
]);
return topCategories.map(category => ({ label: category.categoryName, value: category.totalQuantity }));















const totalUsers = await userModel.countDocuments();
const totalOrders=await Order.countDocuments()

const paymentMethodsData = await Order.aggregate([
  {
    $group: {
      _id: "$paymentOption",
      count: { $sum: 1 },
    },
  },
]);


const paymentMethodsLabels = paymentMethodsData.map(method => method._id);
const paymentMethodsCount = paymentMethodsData.map(method => method.count);



const allOrdersRevenue = await Order.aggregate([
  {
    $group: {
      _id: null,
      totalAmount: { $sum: "$totalAmount" },
    },
  },
]);


const totalAllOrdersRevenue = allOrdersRevenue.length > 0 ? allOrdersRevenue[0].totalAmount : 0;
const averageOrderValue =totalAllOrdersRevenue > 0 ? totalAllOrdersRevenue / totalOrders : 0;
const revenueOrders = await Order.aggregate([
{
$unwind: "$cart.products",
},
{
$match: {
  $or: [
    {
      paymentOption: 'COD',
      'cart.products.orderStatus': 'Delivered',
    },
    {
      paymentOption: { $in: ['Razorpay', 'Wallet'] },
      'cart.products.orderStatus': { $in: ['Placed', 'Shipped', 'Out for delivery', 'Delivered'] },
    },
  ],
  'cart.products.returnOrder.returnStatus': { $ne: 'Refund' },
},

},
{
$group: {
  _id: null,
  totalAmount: { $sum: { $multiply: ['$cart.products.price', '$cart.products.quantity'] } },
},
},
]);

const totalRevenue = revenueOrders.length > 0 ? revenueOrders[0].totalAmount : 0;





const revenuePerProduct = await Order.aggregate([
{
$unwind: "$cart.products",
},
{
$match: {
  $or: [
    { paymentOption: 'COD', 'cart.products.orderStatus': 'Delivered' },
    { paymentOption: { $in: ['Razorpay', 'Wallet'] }, 'cart.products.orderStatus': { $in: ['Placed', 'Shipped', 'Out for delivery', 'Delivered'] } },
  ],
  'cart.products.returnOrder.returnStatus': { $ne: 'Refund' },
},
},
{
$group: {
  _id: '$cart.products.productId',
  totalAmount: { $sum: { $multiply: ['$cart.products.price', '$cart.products.quantity'] } },
},
},
]);



const productIds = revenuePerProduct.map(product => product._id);


const allProducts = await Product.find({}, 'product_name');


const productMap = new Map(allProducts.map(product => [product._id.toString(), product]));

const productData = allProducts.map(product => {
const revenueProduct = revenuePerProduct.find(rp => rp._id.toString() === product._id.toString());
return {
name: product.product_name,
revenue: revenueProduct ? revenueProduct.totalAmount : 0,
};
});

const sortedProducts = productData.sort((a, b) => b.revenue - a.revenue);

const top3Products = sortedProducts.slice(0, 3);


const productLabels = top3Products.map(product => product.name);
const productRevenues = top3Products.map(product => product.revenue);





const revenuePerCategory = await Order.aggregate([
{
$unwind: "$cart.products",
},
{
$match: {
  $or: [
    { paymentOption: 'COD', 'cart.products.orderStatus': 'Delivered' },
    { paymentOption: { $in: ['Razorpay', 'Wallet'] }, 'cart.products.orderStatus': { $in: ['Placed', 'Shipped', 'Out for delivery', 'Delivered'] } },
  ],
  'cart.products.returnOrder.returnStatus': { $ne: 'Refund' },
},
},
{
$lookup: {
  from: 'products', 
  localField: 'cart.products.productId',
  foreignField: '_id',
  as: 'productDetails',
},
},
{
$unwind: "$productDetails",
},
{
$group: {
  _id: '$productDetails.category',
  totalAmount: { $sum: { $multiply: ['$cart.products.price', '$cart.products.quantity'] } },
},
},
]);



const allCategories = await Category.find({}, 'category_name');


const categoryData = allCategories.map(category => ({
name: category.category_name,
revenue: revenuePerCategory.find(c => c._id === category.category_name)?.totalAmount || 0,
}));

const sortedCategories = categoryData.sort((a, b) => b.revenue - a.revenue);

const allCategoryLabels = allCategories.map(category => category.category_name);


const top4Categories = sortedCategories.slice(0, 4);


const categoryLabels = top4Categories.map(category => category.name);
const categoryRevenues = top4Categories.map(category => category.revenue);



const today = new Date();
const lastWeekStartDate = new Date(today);
lastWeekStartDate.setDate(today.getDate() - 7);

const ordersInDateRange = await Order.find({
orderDate: { $gte: lastWeekStartDate, $lte: today },
});


const weeklyrevenueOrders = await Order.aggregate([
{
$match: {
  orderDate: { $gte: lastWeekStartDate, $lte: today },
  'cart.products.orderStatus': 'Delivered',
  $or: [
    { paymentOption: 'COD' },
    { paymentOption: { $in: ['Razorpay', 'Wallet'] } },
  ],
},
},
{
$unwind: "$cart.products",
},
{
$match: {
  'cart.products.returnOrder.returnStatus': { $ne: 'Refund' },
},
},
{
$group: {
  _id: { $dateToString: { format: "%Y-%m-%d", date: "$orderDate" } },
  totalAmount: { $sum: { $multiply: ['$cart.products.price', '$cart.products.quantity'] } },
},
},
{
$sort: {
  _id: 1,
},
},
]);



const allDaysOfLastWeek = [];
let currentDate = new Date(lastWeekStartDate);
while (currentDate <= today) {
allDaysOfLastWeek.push(currentDate.toISOString().split('T')[0]);
currentDate.setDate(currentDate.getDate() + 1);
}

const formattedWeeklyRevenueChartData = allDaysOfLastWeek.map(day => {
const matchingEntry = weeklyrevenueOrders.find(entry => entry._id === day);
return {
date: day,
amount: matchingEntry ? matchingEntry.totalAmount : 0,
};
});

const weeklyRevenueLabels = formattedWeeklyRevenueChartData.map(entry => entry.date);
const weeklyRevenueData = formattedWeeklyRevenueChartData.map(entry => entry.amount);







const monthlyRevenueOrders = await Order.aggregate([
{
$match: {
  orderDate: { $lte: today },
  $or: [
    { paymentOption: 'COD', 'cart.products.orderStatus': 'Delivered' },
    {
      paymentOption: { $in: ['Razorpay', 'Wallet'] },
      'cart.products.orderStatus': { $in: ['Placed', 'Shipped', 'Out for delivery', 'Delivered'] },
    },
  ],
},
},
{
$unwind: "$cart.products",
},
{
$match: {
  'cart.products.returnOrder.returnStatus': { $ne: 'Refund' },
},
},
{
$group: {
  _id: { $dateToString: { format: "%Y-%m", date: "$orderDate" } },
  totalAmount: {
    $sum: {
      $cond: {
        if: { $eq: ['$cart.products.returnOrder.returnStatus', 'Refund'] },
        then: 0, // Exclude refund products
        else: { $multiply: ['$cart.products.price', '$cart.products.quantity'] },
      },
    },
  },
},
},
{
$sort: {
  _id: 1,
},
},
]);




const allMonths = [];
let currentMonthDate = new Date(today.getFullYear(), 0, 1); 
while (currentMonthDate <= today) {
allMonths.push(currentMonthDate.toISOString().split('T')[0].substring(0, 7)); 
currentMonthDate.setMonth(currentMonthDate.getMonth() + 1);
}

const formattedMonthlyRevenueChartData = allMonths.map(month => {
const matchingMonthEntry = monthlyRevenueOrders.find(entry => entry._id === month);
return {
month: month,
amount: matchingMonthEntry ? matchingMonthEntry.totalAmount : 0,
};
});

const currentMonth = today.toISOString().split('T')[0].substring(0, 7);
const currentMonthRevenue = monthlyRevenueOrders.reduce((total, entry) => {
if (entry._id === currentMonth) {
total += entry.totalAmount;
}
return total;
}, 0);

formattedMonthlyRevenueChartData.push({
month: currentMonth,
amount: currentMonthRevenue,
});

const monthlyRevenueLabels = formattedMonthlyRevenueChartData.map(entry => entry.month);
const monthlyRevenueData = formattedMonthlyRevenueChartData.map(entry => entry.amount);




const fiveYearsRevenueOrders = await Order.aggregate([
{
$match: {
  orderDate: { $lte: today },
  $or: [
    { paymentOption: 'COD', 'cart.products.orderStatus': 'Delivered' },
    { paymentOption: { $in: ['Razorpay', 'Wallet'] }, 'cart.products.orderStatus': { $in: ['Placed', 'Shipped', 'Out for delivery', 'Delivered'] } },
  ],
},
},
{
$unwind: "$cart.products",
},
{
$match: {
  'cart.products.returnOrder.returnStatus': { $ne: 'Refund' },
},
},
{
$group: {
  _id: { $dateToString: { format: "%Y", date: "$orderDate" } },
  totalAmount: {
    $sum: {
      $cond: {
        if: { $eq: ['$cart.products.returnOrder.returnStatus', 'Refund'] },
        then: 0, // Exclude refund products
        else: { $multiply: ['$cart.products.price', '$cart.products.quantity'] },
      },
    },
  },
},
},
{
$sort: {
  _id: 1,
},
},
]);




const allYearsFiveYears = [];
let currentYearDateFiveYears = new Date(today.getFullYear() - 5, 0, 1);
while (currentYearDateFiveYears.getFullYear() <= today.getFullYear()) {
allYearsFiveYears.push(currentYearDateFiveYears.toISOString().split('T')[0].substring(0, 4)); // Format as "YYYY"
currentYearDateFiveYears.setFullYear(currentYearDateFiveYears.getFullYear() + 1);
}

const formattedFiveYearsRevenueChartData = allYearsFiveYears.map(year => {
const matchingYearEntry = fiveYearsRevenueOrders.find(entry => entry._id === year);
return {
year: year,
amount: matchingYearEntry ? matchingYearEntry.totalAmount : 0,
};
});

const currentYear = today.toISOString().split('T')[0].substring(0, 4);
const currentYearRevenue = fiveYearsRevenueOrders.reduce((total, entry) => {
if (entry._id === currentYear) {
total += entry.totalAmount;
}
return total;
}, 0);

formattedFiveYearsRevenueChartData.push({
year: currentYear,
amount: currentYearRevenue,
});

const yearlyRevenueLabels = formattedFiveYearsRevenueChartData.map(entry => entry.year);
const yearlyRevenueData = formattedFiveYearsRevenueChartData.map(entry => entry.amount);








res.render('dashboard', {
totalUsers,
totalRevenue,
totalOrders,
averageOrderValue,
paymentMethodsCount,
paymentMethodsLabels,
productLabels,
productRevenues,
categoryLabels,
categoryRevenues,
weeklyRevenueData,
weeklyRevenueLabels,
monthlyRevenueData,
monthlyRevenueLabels,
yearlyRevenueData,
yearlyRevenueLabels,

});









const shopLoad = async (req, res, next) => {
    try {
      const { search, category: selectedCategory, sort } = req.query;
      const page = parseInt(req.query.page) || 1;
      const limit = 6;
  
      const categories = await Category.find({ is_listed: true });
  
      const categoryCounts = await Promise.all(
        categories.map(async (category) => {
          const count = await Product.countDocuments({
            category: { $regex: new RegExp(".*" + category.category_name + ".*", "i") },
          });
          return { name: category.category_name, count };
        })
      );
  
      const filterCriteria = {
        is_listed: true,
      };
  
      if (search) {
        filterCriteria.$or = [
          { product_name: { $regex: new RegExp(".*" + search + ".*", "i") } },
          { category: { $regex: new RegExp(".*" + search + ".*", "i") } },
        ];
      }
  
      if (selectedCategory) {
        filterCriteria.category = {
          $regex: new RegExp(".*" + selectedCategory + ".*", "i"),
        };
      }
  
      let sortOption = {};
  
      if (sort === "lowtohigh") {
        sortOption = { product_price: 1 };
      } else if (sort === "hightolow") {
        sortOption = {  product_price: -1 };
      }
  
      const productsQuery = Product.find(filterCriteria)
        .sort(sortOption)
        .skip((page - 1) * limit)
        .limit(limit);
  
      const countQuery = Product.find(filterCriteria).countDocuments();
  
      const [products, count] = await Promise.all([productsQuery, countQuery]);
  
      const totalPages = Math.ceil(count / limit);
  
      const totalRatings = products.reduce((sum, product) => {
        const productTotalRatings = product.reviews.reduce(
          (sum, review) => sum + review.rating,
          0
        );
        return sum + productTotalRatings;
      }, 0);
  
      const averageRating = count > 0 ? totalRatings / count : 0;
      console.log("Product Names:", products);
  
      res.render("shop", {
        categories,
        categoryCounts,
        products,
        search,
        selectedCategory,
        currentPage: page,
        totalPages,
        user: req.session.user_id,
        averageRating,
        currentSort: sort,
      });
    } catch (error) {
      next(error);
    }
  };




  const shopLoad = async (req, res, next) => {
    try {
      const { search, category: selectedCategory, sort } = req.query;
      const page = parseInt(req.query.page) || 1;
      const limit = 6;
  
      const categories = await Category.find({ is_listed: true });
  
      const categoryCounts = await Promise.all(
        categories.map(async (category) => {
          const count = await Product.countDocuments({
            category: { $regex: new RegExp(".*" + category.category_name + ".*", "i") },
          });
          return { name: category.category_name, count };
        })
      );
  
      const filterCriteria = {
        is_listed: true,
      };
  
      if (search) {
        filterCriteria.$or = [
          { product_name: { $regex: new RegExp(".*" + search + ".*", "i") } },
          { category: { $regex: new RegExp(".*" + search + ".*", "i") } },
        ];
      }
  
      if (selectedCategory) {
        filterCriteria.category = {
          $regex: new RegExp(".*" + selectedCategory + ".*", "i"),
        };
      }
  
      let sortOption = {};
  
      if (sort === "lowtohigh") {
        sortOption = { product_price: 1 };
      } else if (sort === "hightolow") {
        sortOption = {  product_price: -1 };
      }
  
      const productsQuery = Product.find(filterCriteria)
        .sort(sortOption)
        .skip((page - 1) * limit)
        .limit(limit);
  
      const countQuery = Product.find(filterCriteria).countDocuments();
  
      const [products, count] = await Promise.all([productsQuery, countQuery]);
  
      const totalPages = Math.ceil(count / limit);
  
      const totalRatings = products.reduce((sum, product) => {
        const productTotalRatings = product.reviews.reduce(
          (sum, review) => sum + review.rating,
          0
        );
        return sum + productTotalRatings;
      }, 0);
  
      const averageRating = count > 0 ? totalRatings / count : 0;
      console.log("Product Names:", products);
  
      res.render("shop", {
        categories,
        categoryCounts,
        products,
        search,
        selectedCategory,
        currentPage: page,
        totalPages,
        user: req.session.user_id,
        averageRating,
        currentSort: sort,
      });
    } catch (error) {
      next(error);
    }
  };